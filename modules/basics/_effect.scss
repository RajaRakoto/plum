@charset "UTF-8";

//TODO: verified
/// Effect-gradient-radial mixin helps you generate beautiful radial CSS gradients. It uses the radial-gradient CSS property.
/// @param {string} $shape [null, circle, ellipse] - this option sets the shape of the gradient
/// @param {string} $position [top, top-right, right, bottom-right, bottom, bottom-left, left, top-left, center, closest-side, farthest-side, closest-corner, farthest-corner] - sets the position of the gradient’s shape
/// @param {color} $colors - accepts a list of colors with or without the color-stop points. You can pass as many color values ​​as you want
/// @example
///  /* example 1 - circle shape */
///
///  .containing-element {
///  	@include effect-gradient-radial(circle, center, red orange);
///  }
///
///  /* example 2 - ellipse shape */
///
///  .containing-element {
///  	@include effect-gradient-radial(ellipse, center, red orange);
///  }
///
///  /* example 3 - use named arguments */
///
///  .containing-element {
///  	@include effect-gradient-radial(
///  		$shape: circle,
///  		$position: top,
///  		$colors: pink crimson
///  	);
///  }
@mixin effect-gradient-radial($shape, $position, $colors) {
	$list: ();
	$shape: unquote($shape);
	$position: unquote($position);
	@for $i from 1 through length($colors) {
		$list: append($list, nth($colors, $i), comma);
	}
	@if map-has-key($map-for-positions, $position) {
		background: radial-gradient(
			$shape map-get($map-for-positions, $position),
			$list
		);
	} @else if not map-has-key($map-for-positions, $position) {
		background: radial-gradient($shape $position, $list);
	}
}

//TODO: verified
/// Effect-gradient-linear mixin helps you to generate colorful CSS gradients, and it combines them with image and text elements. In this way, you can create beautiful page components.
/// @param {string} $direction [top, top-right, right, bottom-right, bottom, bottom-left, left, top-left] - sets the gradient line’s direction of angle
/// @param {color list} $colors - accepts a list of colors with or without the color-stop points. You can pass as many color values ​​as you want
/// @example
///  body {
///  	@include effect-gradient-linear(left, #43c6ac #191654);
///  }
@mixin effect-gradient-linear($direction, $colors) {
	$list: ();
	@for $i from 1 through length($colors) {
		$list: append($list, nth($colors, $i), comma);
	}
	@if map-has-key($map-for-directions, $direction) {
		background: linear-gradient(
			map-get($map-for-directions, $direction),
			$list
		);
	} @else if not map-has-key($map-for-directions, $direction) {
		@if not index('deg', unit($direction)) {
			@error "#{$direction} is a wrong value for the $direction parameter. The value must be eighter a number followed by the 'deg' unit or one of the followings: #{map-keys($map-for-directions)}.";
		} @else {
			background: linear-gradient($direction, $list);
		}
	}
}

//TODO: verified
/// Simply call the effect-hide mixin to make the selected element and all its children visually hidden (but accessible for screen readers).
/// @param {string} $toggle [hide, unhide] - default value is set to hide, use unhide to reserve the affect
/// @example
///  /* example 1 - hide */
///
///  .containing-element {
///  	@include effect-hide();
///  }
///
///  /* example 2 - unhide */
///
///  .containing-element {
///  	@include effect-hide(unhide);
///  }
@mixin effect-hide($toggle: 'hide') {
	@if $toggle == 'hide' {
		position: absolute;
		width: 1px;
		height: 1px;
		padding: 0;
		border: 0;
		overflow: hidden;
		clip: rect(1px, 1px, 1px, 1px);
		clip-path: inset(100%);
		white-space: nowrap;
	} @else if $toggle == 'unhide' {
		position: static;
		width: auto;
		height: auto;
		overflow: visible;
		clip: auto;
		clip-path: none;
		white-space: inherit;
	} @else if not index ('hide' 'unhide', $toggle) {
		@error "#{$toggle} is not a valid value for the `$toggle` argument. The value must be either `hide` or `unhide`.";
	}
}

//TODO: verified
/// Add an opacity effect on an element (compatible with IE8)
/// @param {percent} $percent - opacity (percent)
/// @example
///  .containing-element {
///	  @include effect-opacity(10%);
///  }
@mixin effect-opacity($percent) {
	opacity: $percent;
	$percent-ie: $percent * 100;
	filter: alpha(opacity=$percent-ie); //IE8
}

//TODO: verified
/// Add an outdoor shadow effect on a container
/// @param {string} $opacity [solid, small, medium, large, none] - opacity values
/// @example
///  .containing-element {
///	  @include effect-box-shadow(small);
///  }
@mixin effect-box-shadow($opacity: solid) {
	@if ($opacity == solid) {
		box-shadow: 1px 1px 2px 1px rgba(20, 20, 20, 0.59);
	} @else if ($opacity == small) {
		box-shadow: 1px 2px 10px 1px rgba(0, 0, 0, 0.59);
		-webkit-box-shadow: 1px 2px 10px 1px rgba(0, 0, 0, 0.59);
		-moz-box-shadow: 1px 2px 10px 1px rgba(0, 0, 0, 0.59);
	} @else if ($opacity == medium) {
		box-shadow: 1px 3px 15px 1px rgba(0, 0, 0, 0.59);
		-webkit-box-shadow: 1px 3px 15px 1px rgba(0, 0, 0, 0.59);
		-moz-box-shadow: 1px 3px 15px 1px rgba(0, 0, 0, 0.59);
	} @else if ($opacity == large) {
		box-shadow: 7px 5px 20px 2px rgba(0, 0, 0, 0.59);
		-webkit-box-shadow: 7px 5px 20px 2px rgba(0, 0, 0, 0.59);
		-moz-box-shadow: 7px 5px 20px 2px rgba(0, 0, 0, 0.59);
	} @else if ($opacity == none) {
		box-shadow: none;
	} @else {
		@error "The argument must be `solid` or `small` or `medium` or `large` or `none`";
	}
}

//TODO: verified
/// Add an interior shadow effect on a container
/// @param {string} $opacity [small, medium, large, none] - opacity values
/// @example
///  .containing-element {
///	  @include effect-box-shadow-inset(large);
///  }
@mixin effect-box-shadow-inset($opacity: medium) {
	@if ($opacity == small) {
		box-shadow: 1px 1px 2px #111 inset;
	} @else if ($opacity == medium) {
		box-shadow: 1px 1px 8px #111 inset;
	} @else if ($opacity == large) {
		box-shadow: 1px 1px 20px #111 inset;
	} @else if ($opacity == none) {
		box-shadow: none;
	} @else {
		@error "The argument must be `small` or `medium` or `large` or `none`";
	}
}

//TODO: verified
/// Add an internal shadow effect on a text
/// @param {string} $opacity [small, medium, large, none] - opacity values
/// @example
///  .p {
///	  @include effect-text-shadow(small);
///  }
@mixin effect-text-shadow($opacity: medium, $color: #222) {
	$list: 'small', 'large', 'none';

	@if ($opacity == small) {
		text-shadow: 0px 1px 2px $color;
	} @else if ($opacity == medium) {
		text-shadow: 0px 1px 8px $color;
	} @else if ($opacity == large) {
		text-shadow: 0px 1px 20px $color;
	} @else if ($opacity == none) {
		text-shadow: none;
	} @else {
		@error "The argument must be `small` or `medium` or `large` or `none`";
	}
}

//TODO: verified
/// Add a glimmer (light effect) external to a text
/// @param {string} $opacity [small, medium, large, none] - opacity values
/// @param {string} $color [#eee] - glimmer color
/// @example
/// /* example 1*/
///
///  .p {
///	  @include effect-text-light(medium);
///  }
///
/// /* example 2*/
///
///  .p {
///	  @include effect-text-light(large, $sun-flower);
///  }
@mixin effect-text-light($opacity: medium, $color: #eee) {
	@if ($opacity == small) {
		text-shadow: 0px 1px 2px $color;
	} @else if ($opacity == medium) {
		text-shadow: 0px 1px 8px $color;
	} @else if ($opacity == large) {
		text-shadow: 0px 1px 20px $color;
	} @else if ($opacity == none) {
		text-shadow: none;
	} @else {
		@error "The argument must be `small` or `medium` or `large` or `none`";
	}
}

//TODO: verified
/// Add a glimmer (light effect) external to a container
/// @param {string} $opacity [solid, small, medium, large, none] - opacity values
/// @param {string} $color [#eee] - glimmer color
/// @example
///  .containing-element {
///	  @include effect-box-light(medium);
///  }
@mixin effect-box-light($opacity: medium, $color: #eee) {
	@if ($opacity == solid) {
		box-shadow: 1px 1px 2px 1px $color;
	} @else if ($opacity == small) {
		box-shadow: 1px 2px 10px 1px $color;
		-webkit-box-shadow: 1px 2px 10px 1px $color;
		-moz-box-shadow: 1px 2px 10px 1px $color;
	} @else if ($opacity == medium) {
		box-shadow: 1px 3px 15px 1px $color;
		-webkit-box-shadow: 1px 3px 15px 1px $color;
		-moz-box-shadow: 1px 3px 15px 1px $color;
	} @else if ($opacity == large) {
		box-shadow: 7px 5px 20px 2px $color;
		-webkit-box-shadow: 7px 5px 20px 2px $color;
		-moz-box-shadow: 7px 5px 20px 2px $color;
	} @else if ($opacity == none) {
		box-shadow: none;
	} @else {
		@error "The argument must be `solid` or `small` or `medium` or `large` or `none`";
	}
}
